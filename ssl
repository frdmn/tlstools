#!/bin/bash

# Exit immediately on error
set -e

# Version
version="v0.1.0"

# Detect whether output is piped or not.
[[ -t 1 ]] && piped=0 || piped=1

# Defaults
force=0
quiet=0
verbose=0
args=()
path=$(dirname "$(realpath $0)")

##
# Helper
##

out() {
  ((quiet)) && return

  local message="$*"
  if ((piped)); then
    message=$(echo $message | sed '
      s/\\[0-9]\{3\}\[[0-9]\(;[0-9]\{2\}\)\?m//g;
      s/✖/Error:/g;
      s/✔/Success:/g;
    ')
  fi
  printf '%b\n' "$message";
}

die() { out "$*"; exit 1; } >&2
err() { out " \033[1;31m✖\033[0m  $*"; } >&2
success() { out " \033[1;32m✔\033[0m  $*"; }

# Verbose logging
verboselog() { (($verbose)) && out "$*"; }

# Notify on function success
notify() { [[ $? == 0 ]] && success "$*" || err "$*"; }

# Escape a string
escape() { echo "$*" | sed 's/\//\\\//g'; }

# Unless force is used, confirm with user
confirm() {
  (($force)) && return 0;

  read -p "$1 [y/N] " -n 1;
  [[ $REPLY =~ ^[Yy]$ ]];
}

# Set a trap for cleaning up in case of errors or when script exits.
rollback() {
  die
}

# Set our rollback function for unexpected exits.
trap rollback INT TERM EXIT

# A non-destructive exit for when the script exits naturally.
safe_exit() {
  trap - INT TERM EXIT
  exit
}

function_exists() {
  declare -f -F $1 > /dev/null
  return $?
}

###
#
###

# Print usage
sub_usage() {
  echo -n "Usage: $ $(basename $0) [OPTION] [COMMAND]...

Description of this script.

 Options:
  -q, --quiet       Quiet (no output)
  -v, --verbose     Output more
  -h, --help        Display this help and exit
      --version     Output version information and exit

 Available commands:
  csr               Quiet (no output)
  host              Output more

  Run \"$(basename $0) [command] -h\" for further information
"
}

# "csr" subcommand
sub_csr() {
  . "${path}/$(basename $0)-csr"
}

# "host" subcommand
sub_host() {
  . "${path}/$(basename $0)-host"
}

###
#
###

# Read the options and set stuff
while [[ $1 = -?* ]]; do
  case $1 in
    -h|--help) sub_usage >&2; safe_exit ;;
    --version) out "$(basename $0) $version"; safe_exit ;;
    -v|--verbose) verbose=1 ;;
    -q|--quiet) quiet=1 ;;
    --endopts) shift; break ;;
    *) die "invalid option: $1" ;;
  esac
  shift
done

subcommand=$1
case $subcommand in
  "" | "-h" | "--help")
    sub_usage
    ;;
  *)
    shift
    if function_exists sub_${subcommand}; then
      sub_${subcommand} "$@"
    else
      err "Error: \"$subcommand\" is not a valid command." >&2
      echo "    Run \"$(basename $0) --help\" for a list of known sub commands." >&2
      exit 1
    fi
    ;;
esac

# This has to be run last not to rollback changes we've made.
safe_exit
